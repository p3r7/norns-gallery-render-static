{"version":3,"sources":["norns_index/utils/core.cljc"],"mappings":"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","names":["norns-index.utils.core/find-indexes","needle","haystack","p1__54267#","p2__54266#","cljs.core.keep_indexed","cljs.core._EQ_","norns-index.utils.core/dissoc-in","m","ks","cljs.core.update_in","cljs.core/butlast","cljs.core/dissoc","cljs.core/last","norns-index.utils.core/entry-member-of-map?","entry","coll","vec__54268","cljs.core.nth","k","v","cljs.core/contains?","cljs.core.get","norns-index.utils.core/member?","cljs.core/coll?","cljs.core.ex_info","cljs.core/set?","cljs.core/map?","cljs.core/vector?","cljs.core/count","cljs.core/first","cljs.core/some","var_args","G__54272","norns-index.utils.core/maintain","js/Error","fx","f","cljs.core.into","cljs.core/empty","xform","norns-index.utils.core/map-vals","cljs.core/persistent!","cljs.core/reduce-kv","cljs.core.assoc_BANG_","cljs.core/transient","norns-index.utils.core/map-keys","norns-index.utils.core/continuous-partition","c","first-partition","cljs.core.partition","second-partition","cljs.core.partition_all","cljs.core/next","cljs.core.interleave","p1__54273#","cljs.core.remove","norns-index.utils.core/keep-in-coll","predicate","norns_index.utils.core.maintain","cljs.core/filter","norns-index.utils.core/keep-vals-in-coll","cljs.core.comp","cljs.core/val","norns-index.utils.core/remove-in-coll","cljs.core/complement","norns-index.utils.core/remove-vals-in-coll","norns-index.utils.core/remove-nils","cljs.core/nil?","norns-index.utils.core/remove-falsy-zero-or-empty","p1__54274#","cljs.core/boolean","cljs.core/empty?","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","norns-index.utils.core/deep-merge","seq54276","self__4724__auto__","cljs.core/seq","maps","xs","p1__54275#","cljs.core/record?","cljs.core.apply","cljs.core/merge-with","cljs.core.reduce","norns-index.utils.core/deep-merge-with","seq54278","G__54279","self__4723__auto__","merge-fn","p1__54277#","cljs.core/every?","norns-index.utils.core/deep-merge-with-ungarded","seq54281","G__54282","p1__54280#","norns-index.utils.core/flattened-map-key","prefix","cljs.core.conj","G__54284","norns-index.utils.core/flatten-map-kvs","map","norns_index.utils.core.flatten_map_kvs","p__54285","vec__54286","memo","cljs.core.concat","norns-index.utils.core/flatten-map","norns-index.utils.core/atom?","o","cljs.core/type","cljs.core/Atom","norns-index.utils.core/multi-merge!","seq54289","G__54290","atom","merges","merged","cljs.core.swap_BANG_","a","norns_index.utils.core.deep_merge"],"sourcesContent":["(ns norns-index.utils.core)\n\n\n\f\n;; COLLECTION: GENERIC\n\n(defn find-indexes [needle haystack]\n  (keep-indexed #(when (= %2 needle) %1) haystack))\n\n(defn dissoc-in\n  \"Like `dissoc` but allowing to pass a path like `assoc-in`.\"\n  [m ks]\n  (update-in m (butlast ks) dissoc (last ks)))\n\n\n\f\n;; COLLECTIONS: PREDICATES\n\n(defn- entry-member-of-map? [entry coll]\n  (let [[k v] entry]\n    (and (contains? coll k)\n         (= v (get coll k)))))\n\n(defn member?\n  \"Returns a truthy value if V is found in collection COLL.\"\n  [v coll]\n\n  (when-not (coll? coll)\n    (throw (ex-info \"Argument `coll` is not a collection\" {:ex-type :unexpected-type})))\n\n  (cond\n    (set? coll) (coll v)                ; sets can be used as fn\n\n    (map? coll)\n    (cond\n      (and (vector? v)\n           (= 2 (count v)))\n      (entry-member-of-map? v coll)\n\n      (and (map? v)\n           (= 1 (count v)))\n      (entry-member-of-map? (first v) coll)\n\n      :default (throw (ex-info \"Argument `coll` is a map, expecting `v` to be a vector of size 2 or map os size 1\"\n                               {:ex-type :unexpected-type,\n                                :v v :coll coll})))\n\n    :default (some #{v} coll)))\n\n\n\f\n;; COLLECTIONS: GENERIC SEQUENCE PROCESSING\n\n(defn maintain\n  \"Apply sequence processing FX (e.g. `map` or `filter`) with entry FN on each element of COLL while keeping the original collection type.\n\n  Taken from book \\\"Clojure the Essential Reference\\\".\"\n  ([fx f coll]\n   (into (empty coll) (fx f coll)))\n  ([xform coll]\n   (into (empty coll) xform coll)))\n\n(defn map-vals\n  \"Returns a lazy hashmap consisting of the result of applying f to\n    the value of each set in hashmap.\n    Function f should accept one single argument.\"\n  [f m]\n  (persistent!\n   (reduce-kv (fn [m k v] (assoc! m k (f v)))\n              (transient (empty m)) m)))\n\n(defn map-keys\n  \"Returns a lazy hashmap consisting of the result of applying f to\n  the key of each set in hashmap.\n  Function f should accept one single argument.\"\n  [f m]\n  (persistent!\n   (reduce-kv (fn [m k v] (assoc! m (f k) v))\n              (transient (empty m)) m)))\n\n\n(defn continuous-partition [c]\n  (let [first-partition (partition 2 c)\n        second-partition (partition-all 2 (next c))]\n    (->> (interleave first-partition second-partition)\n         (remove #(= 1 (count %))))))\n\n\n\f\n;; COLLECTIONS: FILTERING\n\n(defn keep-in-coll\n  \"Return new collection of same type as COLL with only elements satisfying PREDICATE.\"\n  [coll predicate]\n  (when (not (coll? coll))\n    (throw (ex-info \"Argument `coll` is not a collection\"\n                    {:ex-type :unexpected-type,\n                     :coll coll})))\n  (maintain filter predicate coll))\n\n(defn keep-vals-in-coll\n  \"Return new collection of same type as COLL with only elements whose values satisfy PREDICATE.\"\n  [coll predicate]\n  (when (not (coll? coll))\n    (throw (ex-info \"Argument `coll` is not a collection\"\n                    {:ex-type :unexpected-type,\n                     :coll coll})))\n  (let [predicate (if (map? coll)\n                    (comp predicate val)\n                    predicate)]\n    (maintain filter predicate coll)))\n\n(defn remove-in-coll\n  \"Return new collection of same type as COLL with elements satisfying PREDICATE removed.\"\n  [coll predicate]\n  (keep-in-coll coll (complement predicate)))\n\n(defn remove-vals-in-coll\n  \"Return new collection of same type as COLL with elements whose values satisfy PREDICATE removed.\"\n  [coll predicate]\n  (keep-vals-in-coll coll (complement predicate)))\n\n(defn remove-nils [coll]\n  (remove-vals-in-coll coll nil?))\n\n(defn remove-falsy-zero-or-empty [coll]\n  (remove-vals-in-coll coll #(or\n                              (not (boolean %))\n                              (= 0 %)\n                              (and (coll? %)\n                                   (empty? %)))))\n\n\n\f\n;; MAPS: MERGING\n\n(defn deep-merge\n  \"Recursively merges MAPS.\n  Like `merge` but for nested maps.\n\n  Gotten from http://dnaeon.github.io/recursively-merging-maps-in-clojure/\n\n  See also https://cljdoc.org/d/clojure-deep-merge/clojure-deep-merge/0.0.1/api/deep.merge\"\n  [& maps]\n  (letfn [(m [& xs]\n            (if (some #(and (map? %) (not (record? %))) xs)\n              (apply merge-with m xs)\n              (last xs)))]\n    (reduce m maps)))\n\n(defn deep-merge-with\n  \"Recursively merges MAPS and and for deepest shared level use MERGE-FN.\n   Like `merge-into` but for nested maps.\"\n  [merge-fn & maps]\n  (letfn [(m [& xs]\n            (if (every? #(and (map? %) (not (record? %))) xs)\n              (apply merge-with m xs)\n              (apply merge-fn xs)))]\n    (reduce m maps)))\n\n(defn deep-merge-with-ungarded\n  \"Recursively merges MAPS and for deepest level use MERGE-FN.\n  Contrarily to `causal-struct.utils.core/deep-merge-with`, doesn't test the level depth is shared amongst all MAPS.\n  Like `merge-into` but for nested maps.\"\n  [merge-fn & maps]\n  (letfn [(m [& xs]\n            (if (some #(and (map? %) (not (record? %))) xs)\n              (apply merge-with m xs)\n              (apply merge-fn xs)))]\n    (reduce m maps)))\n\n\n\f\n;; MAPS\n\n(defn- flattened-map-key\n  [prefix k]\n  (cond\n    (nil? prefix)\n    [k]\n\n    (vector? prefix)\n    (conj prefix k)\n\n    :default\n    [prefix k]))\n\n(defn- flatten-map-kvs\n  ([map] (flatten-map-kvs map nil))\n  ([map prefix]\n   (reduce\n    (fn [memo [k v]]\n      (if (map? v)\n        (concat memo (flatten-map-kvs v (flattened-map-key prefix k)))\n        (conj memo [(flattened-map-key prefix k) v])))\n    [] map)))\n\n(defn flatten-map\n  [m]\n  (into {} (flatten-map-kvs m)))\n\n\n\f\n;; ATOMS\n\n(defn atom?\n  \"Returns true if O is an atom.\"\n  [o]\n  #?(:clj     (= (class o) clojure.lang.Atom)\n     :cljs    (= (type o) cljs.core/Atom)\n     :default (throw (ex-info \"Platform not supported\" {:ex-type :unexpected-platform}))))\n\n(defn multi-merge!\n  \"Recursively merges collection of maps MERGES into ATOM.\"\n  [atom & merges]\n  (let [merged (apply deep-merge merges)]\n    (swap! atom (fn [a merged]\n                  (deep-merge a merged)) merged)))\n"]}